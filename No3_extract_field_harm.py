import numpy as np
from scipy.integrate import dblquad
from scipy.special import sph_harm, lpmn, factorial
import matplotlib.pyplot as plt

# This Python script calculates the magnetic vector potential components (A_x, A_y, A_z)
# generated by a distant magnetic moment. The potential components are expressed using
# spherical harmonics and scaled by \( \text{refer_radi}^i \) to maintain consistent units.

# Function to compute normalization constant K_n_m for spherical harmonics, 
# which depends on degree i and order m.
def K_n_m(i, m):
    if m == 0:
        return np.sqrt(factorial(int(i - abs(m))) / factorial(int(i + abs(m))) / 4 / np.pi * (2 * i + 1))
    else:
        return np.sqrt(factorial(int(i - abs(m))) / factorial(int(i + abs(m))) / 4 / np.pi * (2 * i + 1)) * np.sqrt(2)

# Function to calculate real spherical harmonics.
def calc_real_Y(i, m, phi, theta):
    Y = sph_harm(abs(m), i, phi, theta)
    if m < 0:
        Y = np.sqrt(2) * (-1) ** (-m) * Y.imag
    elif m > 0:
        Y = np.sqrt(2) * (-1) ** m * Y.real
    return Y.real

# Main function to calculate magnetic vector potential components based on spherical harmonics.
def cal_hamonics(i, m_index, m_dir, r_source, refer_radi):
    z_dir = np.array([0, 0, 1])  # Define the z-axis unit vector.

    r_source_norm = np.linalg.norm(r_source)  # Rho of the Magnetic moment position.
    theta_source = np.arccos(r_source[2] / r_source_norm)  # Polar angle of Magnetic moment position.
    phi_source = np.arctan2(r_source[1], r_source[0])  # Azimuthal angle of Magnetic moment position.
    r_source_dir = r_source / r_source_norm  # Directional vector of Rho.

    ratio = refer_radi / r_source_norm # the ratio between the reference radius and rho
    
    m_norm = np.linalg.norm(m_dir)  # Magnitude of the magnetic moment vector.
    m_dir_norm = m_dir / m_norm  # Unit direction vector of the magnetic moment vector.
    theta_m = np.arccos(m_dir[2] / m_norm)  # Polar angle of the magnetic moment vector.
    phi_m = np.arctan2(m_dir[1], m_dir[0])  # Azimuthal angle of the magnetic moment vector.

    # Validate degree and order for spherical harmonics
    if i < abs(m_index):
        print("Error: Degree i must be greater than or equal to order m.")
        return 0

    # For magnetic moments located at arbitrary angles around z-axis.
    if abs(theta_source) > 1e-6 and abs(theta_source) < (np.pi - 1e-6):
        # Calculate potential contributions from changes in rho, theta, and phi.

        # Contribution from changes in Rho of the Magnetic moment position.
        M_1_temp = (i + 1) / r_source_norm ** 3 / (2 * i + 1) * \
                   calc_real_Y(i, m_index, phi_source, theta_source) * \
                   np.cross(r_source, m_dir) * ratio ** i

        # Contribution from changes in Polar angle of Magnetic moment position.
        M_2_temp_1 = -np.cross(z_dir, m_dir)
        M_2_temp_2 = K_n_m(i, abs(m_index)) / np.sin(theta_source) ** 2 * \
                     ((i + 1) * np.cos(theta_source) * lpmn(abs(m_index), i, np.cos(theta_source))[0][-1][-1] -
                      (i - abs(m_index) + 1) * lpmn(abs(m_index), i + 1, np.cos(theta_source))[0][-1][-1])
        M_2_temp_3 = -r_source[2] / r_source_norm * np.cross(m_dir, r_source_dir)
        M_2_temp = ratio ** i / r_source_norm ** 2 / (2 * i + 1) * (M_2_temp_1 + M_2_temp_3) * M_2_temp_2
        if m_index > 0:
            M_2_temp *= np.cos(m_index * phi_source) * (-1) ** m_index
        elif m_index < 0:
            M_2_temp *= np.sin(-m_index * phi_source) * (-1) ** (-m_index)

        # Contribution from changes in Azimuthal angle of Magnetic moment position.
        M_3_temp_1 = ratio ** i / r_source_norm ** 2 / (2 * i + 1)
        if np.linalg.norm(np.cross(z_dir, m_dir_norm)) >= 1e-6:
            M_3_temp_2_dir_1 = np.cross(z_dir, m_dir_norm)
            M_3_temp_2_dir_2 = np.dot(z_dir, m_dir_norm) * m_dir_norm - z_dir
            M_3_temp_2_dir_2 /= np.linalg.norm(M_3_temp_2_dir_1)
            M_3_temp_2_dir_1 /= np.linalg.norm(M_3_temp_2_dir_1)
        else:
            M_3_temp_2_dir_1, M_3_temp_2_dir_2 = np.array([0, 1, 0]), np.array([1, 0, 0])
        M_3_temp_3 = K_n_m(i, abs(m_index)) * lpmn(abs(m_index), i, np.cos(theta_source))[0][-1][-1]
        M_3_temp_2 = np.cos(theta_m) * np.sin(phi_m - phi_source) / np.sin(theta_source) * M_3_temp_2_dir_1 - \
                     np.cos(phi_m - phi_source) / np.sin(theta_source) * M_3_temp_2_dir_2
        M_3_temp_3_more = -abs(m_index) * np.sin(abs(m_index) * phi_source) * (-1) ** m_index if m_index > 0 else \
                          abs(m_index) * np.cos(abs(m_index) * phi_source) * (-1) ** (-m_index) if m_index < 0 else 0
        M_3_temp = m_norm * M_3_temp_1 * M_3_temp_2 * M_3_temp_3 * M_3_temp_3_more

        # Sum contributions for the final magnetic vector potential.
        final = M_1_temp + M_2_temp + M_3_temp
        return final

    # Specific calculations for magnetic moments on the positive z-axis.
    elif abs(theta_source) <= 1e-6:
        K_n_m_1, K_n_m_0 = K_n_m(i, 1), K_n_m(i, 0)
        if m_index == -1:
            return np.array([m_dir[2] / (2 * i + 1) * K_n_m_1 / r_source_norm ** 2 * (-i * (i + 1)) / 2 * ratio ** i, 0,
                             -m_dir[0] / (2 * i + 1) * K_n_m_1 / r_source_norm ** 2 * (-i * (i + 1)) / 2 * ratio ** i])
        elif m_index == 0:
            return np.array([-m_dir[1] / (2 * i + 1) * K_n_m_0 / r_source_norm ** 2 * (i + 1) * ratio ** i,
                             m_dir[0] / (2 * i + 1) * K_n_m_0 / r_source_norm ** 2 * (i + 1) * ratio ** i, 0])

    # Specific calculations for magnetic moments on the negative z-axis.
    elif abs(theta_source) >= (np.pi - 1e-6):
        K_n_m_1, K_n_m_0 = K_n_m(i, 1), K_n_m(i, 0)
        if m_index == -1:
            return np.array([m_dir[2] / (2 * i + 1) * K_n_m_1 / r_source_norm ** 2 * (-i * (i + 1)) / 2 * (-1) ** (i + 1) * ratio ** i, 0,
                             -m_dir[0] / (2 * i + 1) * K_n_m_1 / r_source_norm ** 2 * (-i * (i + 1)) / 2 * (-1) ** (i + 1) * ratio ** i])
        elif m_index == 0:
            return np.array([-m_dir[1] / (2 * i + 1) * K_n_m_0 / r_source_norm ** 2 * (i + 1) * (-1) ** (i + 1) * ratio ** i,
                             m_dir[0] / (2 * i + 1) * K_n_m_0 / r_source_norm ** 2 * (i + 1) * (-1) ** (i + 1) * ratio ** i, 0])

    return np.array([0, 0, 0])
